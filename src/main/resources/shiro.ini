#使用验证的策略,必须先定义决策,在定义Realm
#SecurityManager 接口继承了 Authenticator，另外还有一个 ModularRealmAuthenticator 实现，其委托给多个 Realm 进行验证，验证规则通过 AuthenticationStrategy 接口指定，默认提供的实现：
#FirstSuccessfulStrategy：只要有一个 Realm 验证成功即可，只返回第一个 Realm 身份验证成功的认证信息，其他的忽略；
#AtLeastOneSuccessfulStrategy：只要有一个 Realm 验证成功即可，和 FirstSuccessfulStrategy 不同，返回所有 Realm 身份验证成功的认证信息；
#AllSuccessfulStrategy：所有 Realm 验证成功才算成功，且返回所有 Realm 身份验证成功的认证信息，如果有一个失败就失败了。
#ModularRealmAuthenticator 默认使用 AtLeastOneSuccessfulStrategy 策略。

#指定securityManager的authenticator实现
authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticator
securityManager.authenticator=$authenticator
#指定securityManager.authenticator的authenticationStrategy
allSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategy
securityManager.authenticator.authenticationStrategy=$allSuccessfulStrategy

#声明一个realm,SecurityManager会加载实例化这个Realm,并根据Realm中实现的方法进行验证和授权
#现在这个配置文件没有定义用户和密码了,所以用户密码可以定义到数据库中
myRealm1=com.rao.study.shiro.auth.MyRealm
myRealm2=com.rao.study.shiro.auth.My2Realm
#指定securityManager的realms实现,使用$进行引用,多个realm的使用,调用顺序根据这里的顺序一致
securityManager.realms=$myRealm1,$myRealm2